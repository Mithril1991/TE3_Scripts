{
  "Actions": [
    {
      "Id": 0,
      "Name": "Replace query string based on Excel file",
      "Enabled": "true",
      "Execute": "using System;\nusing System.Data;\nusing System.Data.OleDb;\nusing System.IO;\n\n// Define variables\nvar _excelFilePath = @\"C:\\Users\\MarekKlucka\\Intelligent Technologies, s.r.o\\Dr. Max - General\\04_Reporty\\IT Reporting\\replace values intune.xlsx\";\nvar _sheetName = \"Before after, manual replace\";\n\n// Connection string for Excel file\nvar _connectionString = $\"Provider=Microsoft.ACE.OLEDB.12.0;Data Source={_excelFilePath};Extended Properties='Excel 12.0 Xml;HDR=YES;'\";\n\n// Load Excel data into a DataTable\nvar _dataTable = new DataTable();\nusing (var _connection = new OleDbConnection(_connectionString))\n{\n    _connection.Open();\n    var _query = $\"SELECT * FROM [{_sheetName}$]\";\n    using (var _adapter = new OleDbDataAdapter(_query, _connection))\n    {\n        _adapter.Fill(_dataTable);\n    }\n}\n\n// Iterate over each row in the DataTable\nforeach (DataRow _row in _dataTable.Rows)\n{\n    var _name = _row[\"Name\"].ToString();\n    var _before = _row[\"Before\"].ToString();\n    var _after = _row[\"After\"].ToString();\n\n    // Debugging output\n    // Console.WriteLine($\"This name will be replaced from \\\"{_before}\\\" to \\\"{_after}\\\".\");\n    Output($\"The query \\\"{_name}\\\" will be replaced from \\\"{_before}\\\" to \\\"{_after}\\\".\");\n    // Uncomment the following lines to perform the actual replacement\n    /*\n    var _query = Model.Tables.FindByName(_name);\n    if (_query != null)\n    {\n        _query.Query = _query.Query.Replace(_before, _after);\n    }\n    else\n    {\n        Console.WriteLine($\"Table or query with name '{_name}' not found.\");\n    }\n    */\n}\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 2,
      "Name": "Mermaid measure dependencies",
      "Enabled": "true",
      "Execute": "string dependancies = \"flowchart LR\\n%% Measure dependancy mermaid flowchart\";\n\nforeach(var _measures in Model.AllMeasures ) \n{\n    var _upstream = _measures.DependsOn;\n    var _upstream_measures = _upstream.Measures.OfType<Measure>().Select(c => c).Distinct();\n\n    string mermaidSafeName = _measures.Name.Replace(\" \", \"_\").Replace(\">\", \"_gt_\").Replace(\"<\", \"_lt_\").Replace(\"%\", \"pct\");\n\n    dependancies += string.Format(\"\\r\\n\\n%% {0} Dependancies:\\n\\t{1}[\\\"{0}\\\"]\", \n        _measures.Name, \n        mermaidSafeName\n    );\n\n    foreach(var measure_dependencies in _upstream_measures)\n    { \n        string depMermaidSafeName = measure_dependencies.Name.Replace(\" \", \"_\").Replace(\">\", \"_gt_\").Replace(\"<\", \"_lt_\").Replace(\"%\", \"pct\");\n        \n        dependancies += string.Format(\"\\r\\n\\t{1}[\\\"{0}\\\"] --> {3}[\\\"{2}\\\"]\", \n            measure_dependencies.Name, \n            depMermaidSafeName,\n            _measures.Name, \n            mermaidSafeName\n        );\n    }\n}\n\ndependancies.Output();\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 3,
      "Name": "Find text in measures",
      "Enabled": "true",
      "Execute": "// Manually set the search term you want to look for in measures\nvar searchText = \"SUM(\"; // Change this value as needed\n\n// Create a list to collect measure names that contain the search text\nvar output = new List<string>();\n\n// Loop through each measure in the model\nforeach (var measure in Model.AllMeasures)\n{\n    // Check if the formula contains the search text (case-insensitive)\n    if (measure.Expression.ToLower().Contains(searchText.ToLower()))\n    {\n        // Add the measure name to the output list\n        output.Add(measure.Name);\n    }\n}\n\n// Output the result in the Advanced Scripting output pane as concatenated text\nif (output.Count > 0)\n{\n    // Join all measure names with \"; \" followed by a new line and output as a single string\n    Output(string.Join(\"; \" + Environment.NewLine, output));\n}\nelse\n{\n    Output($\"No measures contain '{searchText}'.\");\n}\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 4,
      "Name": "Aggregated columns from selection",
      "Enabled": "true",
      "Execute": "// Creates a aggregating measures for every currently selected column and hide the column.\r\nforeach(var c in Selected.Columns)\r\n{\r\n    var newMeasure1 = c.Table.AddMeasure(\r\n        \"Sum of \" + c.Name,                             // Name\r\n        \"SUM(\" + c.DaxObjectFullName + \")\",             // DAX expression\r\n        c.DisplayFolder                                 // Display Folder\r\n    );\r\n    var newMeasure2 = c.Table.AddMeasure(\r\n        \"Count of \" + c.Name,                           // Name\r\n        \"COUNT(\" + c.DaxObjectFullName + \")\",           // DAX expression\r\n        c.DisplayFolder                                 // Display Folder\r\n    );\r\n    var newMeasure3 = c.Table.AddMeasure(\r\n        \"Distinct count of \" + c.Name,                  // Name\r\n        \"DISTINCTCOUNT(\" + c.DaxObjectFullName + \")\",   // DAX expression\r\n        c.DisplayFolder                                 // Display Folder\r\n    );\r\n    var newMeasure4 = c.Table.AddMeasure(\r\n        \"Average of \" + c.Name,                         // Name\r\n        \"AVERAGE(\" + c.DaxObjectFullName + \")\",         // DAX expression\r\n        c.DisplayFolder                                 // Display Folder\r\n    );\r\n    var newMeasure5 = c.Table.AddMeasure(\r\n        \"Min of \" + c.Name,                             // Name\r\n        \"MIN(\" + c.DaxObjectFullName + \")\",             // DAX expression\r\n        c.DisplayFolder                                 // Display Folder\r\n    );\r\n    var newMeasure6 = c.Table.AddMeasure(\r\n        \"Max of \" + c.Name,                             // Name\r\n        \"MAX(\" + c.DaxObjectFullName + \")\",             // DAX expression\r\n        c.DisplayFolder                                 // Display Folder\r\n    );\r\n                        \r\n    // Set the format string on the new measure:\r\n    newMeasure1.FormatString = \"0.00\";\r\n    newMeasure2.FormatString = \"0.00\";\r\n    newMeasure3.FormatString = \"0.00\";    \r\n    newMeasure4.FormatString = \"0.00\";\r\n    newMeasure5.FormatString = \"0.00\";\r\n    newMeasure6.FormatString = \"0.00\";    \r\n    // Provide some documentation:\r\n    newMeasure1.Description = \"This measure is the sum of column \" + c.DaxObjectFullName;\r\n    newMeasure2.Description = \"This measure is the count of column \" + c.DaxObjectFullName;\r\n    newMeasure3.Description = \"This measure is the distinct count of column \" + c.DaxObjectFullName;\r\n    newMeasure4.Description = \"This measure is the average of column \" + c.DaxObjectFullName;\r\n    newMeasure5.Description = \"This measure is the min of column \" + c.DaxObjectFullName;\r\n    newMeasure6.Description = \"This measure is the max of column \" + c.DaxObjectFullName;\r\n\r\n    // Hide the base column:\r\n    c.IsHidden = true;\r\n}\r\n\r\n",
      "Tooltip": "",
      "ValidContexts": "Column"
    },
    {
      "Id": 5,
      "Name": "All measures list",
      "Enabled": "true",
      "Execute": "// Create a variable to store the output\r\nvar output = new System.Text.StringBuilder();\r\n\r\n// Loop through all the tables in the model\r\nforeach (var table in Model.Tables) \r\n{\r\n    // Loop through all measures in the current table\r\n    foreach (var measure in table.Measures) \r\n    {\r\n        // Append the measure's table name, measure name, and DAX expression to the output variable\r\n        output.AppendLine(\"Table: \" + table.Name);\r\n        output.AppendLine(\"Measure: \" + measure.Name);\r\n        output.AppendLine(\"DAX Expression: \" + measure.Expression);\r\n        output.AppendLine(new string('-', 50)); // Separator\r\n    }\r\n}\r\n\r\n// Display the output in the results window\r\nOutput(output.ToString());\r\n",
      "Tooltip": "This is creating list of measures to see the model dependencies of measures",
      "ValidContexts": "Model, Table, Measure, Hierarchy"
    },
    {
      "Id": 6,
      "Name": "BP Rules MKI",
      "Enabled": "true",
      "Execute": "System.Net.WebClient w = new System.Net.WebClient(); \r\n\r\nstring path = System.Environment.GetFolderPath(System.Environment.SpecialFolder.LocalApplicationData);\r\nstring url = \"https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json\";\r\nstring version = System.Windows.Forms.Application.ProductVersion.Substring(0,1);\r\nstring downloadLoc = path+@\"\\TabularEditor\\BPARules.json\";\r\n\r\nif (version == \"3\")\r\n{\r\n    downloadLoc = path+@\"\\TabularEditor3\\BPARules.json\";\r\n}\r\n\r\nw.DownloadFile(url, downloadLoc);",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 7,
      "Name": "Change all table references in DAX ",
      "Enabled": "true",
      "Execute": "// Loop through each measure in the model\r\nforeach (var measure in Model.AllMeasures)\r\n{\r\n    // Check if the formula contains the text \"oldTable\"\r\n    if (measure.Expression.Contains(\"_CALC\"))\r\n    {\r\n        // Replace \"oldTable\" with \"newTable\" in the formula\r\n        measure.Expression = measure.Expression.Replace(\"_CALC\", \"\");\r\n    }\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 8,
      "Name": "Change all table references in DAX (selected)",
      "Enabled": "true",
      "Execute": "// Loop through each measure in the model\r\nforeach (var measure in Selected.Measures)\r\n{\r\n    // Check if the formula contains the text \"oldTable\"\r\n    if (measure.Expression.Contains(\"oldTable\"))\r\n    {\r\n        // Replace \"oldTable\" with \"newTable\" in the formula\r\n        measure.Expression = measure.Expression.Replace(\"oldTable\", \"newTable\");\r\n    }\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 9,
      "Name": "ExportModelDescriptions",
      "Enabled": "true",
      "Execute": "#r \"System.IO\"\r\n#r \"Microsoft.Office.Interop.Excel\"\r\n\r\nusing System.IO;\r\nusing Excel = Microsoft.Office.Interop.Excel;\r\nusing System.Text.RegularExpressions;\r\n\r\nstring filePath = @\"C:\\Users\\MarekKlucka\\OneDrive - Intelligent Technologies, s.r.o\\Dokumenty\\PowerBI\\StockAvailability_Gen2\"; // Update this to be the desired location of the Descriptions file\r\nstring excelFilePath = filePath + \".xlsx\"; \r\nstring textFilePath = filePath + \".txt\";\r\nstring excelTabName = \"ModelDescriptions\";\r\nvar sb = new System.Text.StringBuilder();\r\nstring newline = Environment.NewLine;\r\n\r\nsb.Append(\"TableName\" + '\\t' + \"ObjectType\" + '\\t' + \"ObjectName\" + '\\t' + \"HiddenFlag\" + '\\t' + \"Description\" +'\\t' + \"DAX Expressions\" + newline);\r\n\r\nforeach (var t in Model.Tables.Where(a => a.ObjectType.ToString() != \"CalculationGroupTable\").OrderBy(a => a.Name).ToList())\r\n{\r\n    string tableName = t.Name;\r\n    string tableDesc = t.Description;\r\n    string tblhid;\r\n    \r\n    if (t.IsHidden)\r\n    {\r\n        tblhid = \"Yes\";\r\n    }\r\n    else\r\n    {\r\n        tblhid = \"No\";\r\n    }\r\n    \r\n    sb.Append(tableName + '\\t' + \"Table\" + '\\t' + tableName + '\\t' + tblhid + '\\t' + tableDesc + newline);\r\n    \r\n    foreach (var o in t.Columns.OrderBy(a => a.Name).ToList())\r\n    {\r\n        string objName = o.Name;\r\n        string objDesc = o.Description;\r\n        string objhid;\r\n    \r\n        if (o.IsHidden)\r\n        {\r\n            objhid = \"Yes\";\r\n        }\r\n        else\r\n        {\r\n            objhid = \"No\";\r\n        }\r\n        \r\n        sb.Append(tableName + '\\t' + \"Column\" + '\\t' + objName + '\\t' + objhid + '\\t' + objDesc + newline);        \r\n    }\r\n    \r\n    foreach (var o in t.Measures.OrderBy(a => a.Name).ToList())\r\n    {\r\n        string objName = o.Name;\r\n        string objDesc = o.Description;\r\n        string objhid;\r\n        string objExpression = o.Expression;\r\n        objExpression = Regex.Replace(objExpression, @\"\\r\\n?|\\n\", string.Empty); \r\n    \r\n        if (o.IsHidden)\r\n        {\r\n            objhid = \"Yes\";\r\n        }\r\n        else\r\n        {\r\n            objhid = \"No\";\r\n        }\r\n        \r\n        sb.Append(tableName + '\\t' + \"Measure\" + '\\t' + objName + '\\t' + objhid + '\\t' + objDesc + '\\t' + objExpression + newline);        \r\n    }\r\n    \r\n    foreach (var o in t.Hierarchies.OrderBy(a => a.Name).ToList())\r\n    {\r\n        string objName = o.Name;\r\n        string objDesc = o.Description;\r\n        string objhid;\r\n    \r\n        if (o.IsHidden)\r\n        {\r\n            objhid = \"Yes\";\r\n        }\r\n        else\r\n        {\r\n            objhid = \"No\";\r\n        }\r\n        \r\n        sb.Append(tableName + '\\t' + \"Hierarchy\" + '\\t' + objName + '\\t' + objhid + '\\t' + objDesc + newline);        \r\n    }    \r\n}\r\n\r\nforeach (var o in Model.CalculationGroups.OrderBy(a => a.Name).ToList())\r\n{\r\n    string tableName = o.Name;\r\n    string tableDesc = o.Description;\r\n    string tblhid;\r\n    \r\n    if (o.IsHidden)\r\n    {\r\n        tblhid = \"Yes\";\r\n    }\r\n    else\r\n    {\r\n        tblhid = \"No\";\r\n    }\r\n    \r\n    sb.Append(tableName + '\\t' + \"Calculation Group\" + '\\t' + tableName + '\\t' + tblhid + '\\t' + tableDesc + newline);  \r\n    \r\n    foreach (var i in o.CalculationItems.ToList())\r\n    {        \r\n        string objName = i.Name;\r\n        string objDesc = i.Description;\r\n        \r\n        sb.Append(tableName + '\\t' + \"Calculation Item\" + '\\t' + objName + '\\t' + \"No\" + '\\t' + objDesc + newline);        \r\n    }\r\n}\r\n\r\n// Delete existing text/Excel files\r\ntry\r\n{\r\n    File.Delete(textFilePath);\r\n    File.Delete(excelFilePath);\r\n}\r\ncatch\r\n{\r\n}\r\n\r\n// Save to text file\r\nSaveFile(textFilePath, sb.ToString());\r\n\r\n// Save to Excel file\r\nvar excelApp = new Excel.Application();\r\nexcelApp.Visible = false;\r\nexcelApp.DisplayAlerts = false;\r\nexcelApp.Workbooks.OpenText(textFilePath, 65001, 1, Excel.XlTextParsingType.xlDelimited, Excel.XlTextQualifier.xlTextQualifierNone, false, true, false, false, false, false, false, Type.Missing, Type.Missing, Type.Missing, Type.Missing, true, Type.Missing);\r\n\r\nvar wb = excelApp.ActiveWorkbook;\r\nvar ws = wb.ActiveSheet as Excel.Worksheet;\r\nws.Name = excelTabName;\r\nwb.SaveAs(excelFilePath, Excel.XlFileFormat.xlWorkbookDefault, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Excel.XlSaveAsAccessMode.xlNoChange);\r\n\r\n// Close workbook and quit Excel program\r\nwb.Close();\r\nexcelApp.Quit();\r\nSystem.Runtime.InteropServices.Marshal.ReleaseComObject(excelApp);\r\n\r\n// Delete text file as it is no longer necessary\r\ntry\r\n{\r\n    File.Delete(textFilePath);\r\n}\r\ncatch\r\n{\r\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 10,
      "Name": "Format all the Things (FAT)",
      "Enabled": "true",
      "Execute": "\r\n// ----------------------------- MEASURES --------------------------------------- //\r\n\r\n// Format all DAX measures in the model\r\nvar _measures = Model.AllMeasures;\r\n_measures.FormatDax();\r\n\r\n// Count & report in an info box the # measures formatted\r\n\r\n\r\n// ----------------------------- CALCULATION GROUPS ----------------------------- //\r\n\r\n// Loop through calculation groups & items, counting and formatting them\r\nint _counter = 0;\r\nforeach (  var _calcgroup  in Model.CalculationGroups )\r\n{\r\n foreach (  var _item  in _calcgroup.CalculationItems )\r\n {\r\n _counter = _counter + 1;\r\n _item.Expression = \"\\n\" + FormatDax( _item.Expression, shortFormat: true );\r\n }\r\n}\r\n\r\n\r\n// ----------------------------- CALCULATED TABLES ----------------------------- //\r\n\r\n// Loop through calculated tables in the model and format their DAX expressions\r\nforeach (  var _tables  in Model.Tables )\r\n{\r\n\r\nif (_tables.Columns.Count > 0 && Convert.ToString(_tables.Columns[0].Type) == \"CalculatedTableColumn\")\r\n{\r\n  _tables.Partitions[0].Expression = \"\\n\" + FormatDax(_tables.Partitions[0].Expression, shortFormat: true);\r\n}\r\n\r\n}\r\n\r\n// Count & report in an info box the # Calculated Tables formatted\r\nint _nrtables = Model.Tables.Where(_tables => _tables.Columns.Count > 0 && Convert.ToString(_tables.Columns[0].Type) == \"CalculatedTableColumn\").Count();\r\n\r\n\r\n\r\n// ----------------------------- CALCULATED COLUMNS ----------------------------- //\r\n\r\n// Loop through calculated columns in the model and format their DAX expressions\r\nforeach (  var _columns  in Model.AllColumns )\r\n{\r\n if ( Convert.ToString( _columns.Type ) == \"Calculated\")\r\n {\r\n (_columns as CalculatedColumn).Expression = \"\\n\" + FormatDax( (_columns as CalculatedColumn).Expression, shortFormat: true );\r\n }\r\n}\r\n\r\n// Count the # Calculated Columns formatted\r\nint _nrcolumns = Model.AllColumns.Where(_columns => Convert.ToString(_columns.Type) == \"Calculated\").Count();\r\n\r\n\r\n\r\n\r\n// Return an info box counting what was formatted\r\nInfo(   \"Formatted all the things! \\n\\n\" +\r\n        Convert.ToString(_measures.Count()) + \" measures,\\n\" + \r\n        Convert.ToString( _counter ) + \" calculation items, \\n\" + \r\n        Convert.ToString( _nrtables ) + \" calculated tables &\\n\" + \r\n        Convert.ToString( _nrcolumns ) + \" calculated columns.\" );",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 11,
      "Name": "graphviz measure dependencies",
      "Enabled": "true",
      "Execute": "// Initialize the Graphviz DOT format string\r\nstring graphviz = \"digraph G {\\n\";\r\n\r\n// Iterate over all measures in the model\r\nforeach (var _measures in Model.AllMeasures) {\r\n    var _upstream = _measures.DependsOn; // Get dependencies of the measure\r\n    var _upstream_measures = _upstream.Measures.OfType<Measure>().Select(c => c).Distinct(); // Extract distinct upstream measures\r\n\r\n    // Define a node for the current measure using its LineageTag as the identifier and its Name as the label\r\n    graphviz += string.Format(\"    \\\"{0}\\\" [label=\\\"{1}\\\"];\\n\", _measures.LineageTag, _measures.Name);\r\n\r\n    // Iterate through each dependency measure and create edges\r\n    foreach (var measure_dependencies in _upstream_measures) {\r\n        graphviz += string.Format(\"    \\\"{0}\\\" -> \\\"{1}\\\";\\n\",\r\n                                  measure_dependencies.LineageTag, // Lineage tag of the dependent measure\r\n                                  _measures.LineageTag); // Lineage tag of the current measure\r\n    }\r\n}\r\n\r\n// Close the graph definition\r\ngraphviz += \"}\\n\";\r\n\r\ngraphviz.Output();",
      "Tooltip": "This is creating list of measures to see the model dependencies of measures",
      "ValidContexts": "Model, Table, Measure, Hierarchy"
    },
    {
      "Id": 12,
      "Name": "ImportModelDescriptions",
      "Enabled": "true",
      "Execute": "#r \"System.IO\"\r\n#r \"Microsoft.Office.Interop.Excel\"\r\n\r\nusing System.IO;\r\nusing Excel = Microsoft.Office.Interop.Excel;\r\n\r\nstring filePath = @\"C:\\Users\\MarekKlucka\\OneDrive - Intelligent Technologies, s.r.o\\Dokumenty\\PowerBI\\StockAvailability_Gen2\"; // Update this to be the location of the Descriptions file\r\nstring excelFilePath = filePath + \".xlsx\"; \r\nstring excelTabName = \"ModelDescriptions\";\r\n\r\n// Open Excel\r\nvar excelApp = new Excel.Application();\r\nexcelApp.Visible = false;\r\nexcelApp.DisplayAlerts = false;\r\n\r\n// Open Workbook, Worksheet\r\nvar wb = excelApp.Workbooks.Open(excelFilePath); \r\nvar ws = wb.Worksheets[excelTabName] as Excel.Worksheet;\r\n\r\n// Count rows and columns\r\nExcel.Range xlRange = ws.UsedRange;\r\n\r\nint rowCount = xlRange.Rows.Count;\r\n\r\nfor (int r = 2; r <= rowCount; r++)\r\n{\r\n    string tableName = (string)(ws.Cells[r,1] as Excel.Range).Text.ToString();\r\n    string objType = (string)(ws.Cells[r,2] as Excel.Range).Text.ToString();\r\n    string objName = (string)(ws.Cells[r,3] as Excel.Range).Text.ToString();\r\n    string desc = (string)(ws.Cells[r,5] as Excel.Range).Text.ToString();\r\n    string objExpression = (string)(ws.Cells[r,6] as Excel.Range).Text.ToString();\r\n    \r\n    if (objType == \"Table\")\r\n    {\r\n        try\r\n        {\r\n            Model.Tables[tableName].Description = desc;\r\n        }\r\n        catch\r\n        {\r\n        }\r\n    }\r\n    else if (objType == \"Column\")\r\n    {\r\n        try\r\n        {\r\n            Model.Tables[tableName].Columns[objName].Description = desc;\r\n        }\r\n        catch\r\n        {            \r\n        }\r\n    }\r\n    else if (objType == \"Measure\")\r\n    {\r\n        try\r\n        {\r\n            Model.Tables[tableName].Measures[objName].Description = desc;\r\n        }\r\n        catch\r\n        {\r\n        }\r\n    }\r\n    else if (objType == \"Hierarchy\")\r\n    {\r\n        try\r\n        {\r\n            Model.Tables[tableName].Hierarchies[objName].Description = desc;\r\n        }\r\n        catch\r\n        {\r\n        }\r\n    }\r\n    else if (objType == \"Calculation Group\")\r\n    {\r\n        try\r\n        {\r\n            Model.Tables[tableName].Description = desc;\r\n        }\r\n        catch\r\n        {\r\n        }\r\n    }\r\n    else if (objType == \"Calculation Item\")\r\n    {\r\n        try\r\n        {\r\n            (Model.Tables[tableName] as CalculationGroupTable).CalculationItems[objName].Description = desc;\r\n        }\r\n        catch\r\n        {\r\n        }\r\n    }\r\n}\r\n\r\n// Close workbook and quit Excel program\r\nwb.Close();\r\nexcelApp.Quit();\r\nSystem.Runtime.InteropServices.Marshal.ReleaseComObject(excelApp);",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 13,
      "Name": "Mermaid javascript creation",
      "Enabled": "true",
      "Execute": "string dependancies = \"flowchart LR\\n%% Measure dependancy mermaid flowchart\";\r\n\r\nforeach(var _measures in Model.AllMeasures ) \r\n    {\r\n\r\n    var _upstream           = _measures.DependsOn;\r\n    var _upstream_measures  = _upstream.Measures.OfType<Measure>().Select(c => c).Distinct();\r\n\r\n    dependancies += string.Format(\"\\r\\n\\n%% [{1}] Dependancies:\\n\\t{0}[\\\"{1}\\\"]\", \r\n\r\n        // 0 - Lineage tag of the measure in scope\r\n        _measures.LineageTag, \r\n\r\n        // 1 - Name of the measure in scope\r\n        _measures.Name);\r\n\r\n    foreach( var measure_dependencies in _upstream_measures )\r\n        { \r\n        dependancies += string.Format(\"\\r\\n\\t{2}[\\\"{3}\\\"] --> {0}[\\\"{1}\\\"]\", \r\n            \r\n            // 0 - Lineage tag of the measure in scope\r\n            _measures.LineageTag, \r\n            \r\n            // 1 - Name of the measure in scope\r\n            _measures.Name,\r\n            \r\n            // 2 - Lineage tag of the dependant measure\r\n            measure_dependencies.LineageTag, \r\n            \r\n            // 3 - Name of the dependant measure\r\n            measure_dependencies.Name);\r\n        }\r\n    }\r\n\r\ndependancies.Output();",
      "Tooltip": "This is creating list of measures to see the model dependencies of measures",
      "ValidContexts": "Model, Table, Measure, Hierarchy"
    },
    {
      "Id": 14,
      "Name": "ModelDescriptions",
      "Enabled": "true",
      "Execute": "#r \"System.IO\"\r\n#r \"Microsoft.Office.Interop.Excel\"\r\n\r\nusing System.IO;\r\nusing Excel = Microsoft.Office.Interop.Excel;\r\n\r\nstring filePath = @\"C:\\Users\\MarekKlucka\\OneDrive - Intelligent Technologies, s.r.o\\Dokumenty\\PowerBI\\PharmacyDescription\"; // Update this to be the desired location of the Descriptions file\r\nstring excelFilePath = filePath + \".xlsx\"; \r\nstring textFilePath = filePath + \".txt\";\r\nstring excelTabName = \"ModelDescriptions\";\r\nvar sb = new System.Text.StringBuilder();\r\nstring newline = Environment.NewLine;\r\n\r\nsb.Append(\"TableName\" + '\\t' + \"ObjectType\" + '\\t' + \"ObjectName\" + '\\t' + \"HiddenFlag\" + '\\t' + \"Description\" + newline);\r\n\r\nforeach (var t in Model.Tables.Where(a => a.ObjectType.ToString() != \"CalculationGroupTable\").OrderBy(a => a.Name).ToList())\r\n{\r\n    string tableName = t.Name;\r\n    string tableDesc = t.Description;\r\n    string tblhid;\r\n    \r\n    if (t.IsHidden)\r\n    {\r\n        tblhid = \"Yes\";\r\n    }\r\n    else\r\n    {\r\n        tblhid = \"No\";\r\n    }\r\n    \r\n    sb.Append(tableName + '\\t' + \"Table\" + '\\t' + tableName + '\\t' + tblhid + '\\t' + tableDesc + newline);\r\n    \r\n    foreach (var o in t.Columns.OrderBy(a => a.Name).ToList())\r\n    {\r\n        string objName = o.Name;\r\n        string objDesc = o.Description;\r\n        string objhid;\r\n    \r\n        if (o.IsHidden)\r\n        {\r\n            objhid = \"Yes\";\r\n        }\r\n        else\r\n        {\r\n            objhid = \"No\";\r\n        }\r\n        \r\n        sb.Append(tableName + '\\t' + \"Column\" + '\\t' + objName + '\\t' + objhid + '\\t' + objDesc + newline);        \r\n    }\r\n    \r\n    foreach (var o in t.Measures.OrderBy(a => a.Name).ToList())\r\n    {\r\n        string objName = o.Name;\r\n        string objDesc = o.Description;\r\n        string objhid;\r\n    \r\n        if (o.IsHidden)\r\n        {\r\n            objhid = \"Yes\";\r\n        }\r\n        else\r\n        {\r\n            objhid = \"No\";\r\n        }\r\n        \r\n        sb.Append(tableName + '\\t' + \"Measure\" + '\\t' + objName + '\\t' + objhid + '\\t' + objDesc + newline);        \r\n    }\r\n    \r\n    foreach (var o in t.Hierarchies.OrderBy(a => a.Name).ToList())\r\n    {\r\n        string objName = o.Name;\r\n        string objDesc = o.Description;\r\n        string objhid;\r\n    \r\n        if (o.IsHidden)\r\n        {\r\n            objhid = \"Yes\";\r\n        }\r\n        else\r\n        {\r\n            objhid = \"No\";\r\n        }\r\n        \r\n        sb.Append(tableName + '\\t' + \"Hierarchy\" + '\\t' + objName + '\\t' + objhid + '\\t' + objDesc + newline);        \r\n    }    \r\n}\r\n\r\nforeach (var o in Model.CalculationGroups.OrderBy(a => a.Name).ToList())\r\n{\r\n    string tableName = o.Name;\r\n    string tableDesc = o.Description;\r\n    string tblhid;\r\n    \r\n    if (o.IsHidden)\r\n    {\r\n        tblhid = \"Yes\";\r\n    }\r\n    else\r\n    {\r\n        tblhid = \"No\";\r\n    }\r\n    \r\n    sb.Append(tableName + '\\t' + \"Calculation Group\" + '\\t' + tableName + '\\t' + tblhid + '\\t' + tableDesc + newline);  \r\n    \r\n    foreach (var i in o.CalculationItems.ToList())\r\n    {        \r\n        string objName = i.Name;\r\n        string objDesc = i.Description;\r\n        \r\n        sb.Append(tableName + '\\t' + \"Calculation Item\" + '\\t' + objName + '\\t' + \"No\" + '\\t' + objDesc + newline);        \r\n    }\r\n}\r\n\r\n// Delete existing text/Excel files\r\ntry\r\n{\r\n    File.Delete(textFilePath);\r\n    File.Delete(excelFilePath);\r\n}\r\ncatch\r\n{\r\n}\r\n\r\n// Save to text file\r\nSaveFile(textFilePath, sb.ToString());\r\n\r\n// Save to Excel file\r\nvar excelApp = new Excel.Application();\r\nexcelApp.Visible = false;\r\nexcelApp.DisplayAlerts = false;\r\nexcelApp.Workbooks.OpenText(textFilePath, 65001, 1, Excel.XlTextParsingType.xlDelimited, Excel.XlTextQualifier.xlTextQualifierNone, false, true, false, false, false, false, false, Type.Missing, Type.Missing, Type.Missing, Type.Missing, true, Type.Missing);\r\n\r\nvar wb = excelApp.ActiveWorkbook;\r\nvar ws = wb.ActiveSheet as Excel.Worksheet;\r\nws.Name = excelTabName;\r\nwb.SaveAs(excelFilePath, Excel.XlFileFormat.xlWorkbookDefault, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Excel.XlSaveAsAccessMode.xlNoChange);\r\n\r\n// Close workbook and quit Excel program\r\nwb.Close();\r\nexcelApp.Quit();\r\nSystem.Runtime.InteropServices.Marshal.ReleaseComObject(excelApp);\r\n\r\n// Delete text file as it is no longer necessary\r\ntry\r\n{\r\n    File.Delete(textFilePath);\r\n}\r\ncatch\r\n{\r\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 15,
      "Name": "Stop refresh",
      "Enabled": "true",
      "Execute": "#r \"Microsoft.AnalysisServices.Core.dll\"\r\n\r\nvar DMV_Cmd = ExecuteDax(\"SELECT [SESSION_ID],[SESSION_LAST_COMMAND] FROM $SYSTEM.DISCOVER_SESSIONS\").Tables[0];\r\nbool runTMSL = true;\r\nstring databaseID = Model.Database.ID;\r\nstring databaseName = Model.Database.Name;\r\nstring sID = string.Empty;\r\n\r\nfor (int r = 0; r < DMV_Cmd.Rows.Count; r++)\r\n{\r\n    string sessionID = DMV_Cmd.Rows[r][0].ToString();\r\n    string cmdText = DMV_Cmd.Rows[r][1].ToString();\r\n    \r\n    // Capture refresh command for the database\r\n    if (cmdText.StartsWith(\"<Batch Transaction=\") && cmdText.Contains(\"<Refresh xmlns\") && cmdText.Contains(\"<DatabaseID>\"+databaseID+\"</DatabaseID>\"))\r\n    {\r\n        sID = sessionID;\r\n    }      \r\n}\r\n\r\nif (sID == string.Empty)\r\n{\r\n    Error(\"No processing Session ID found for the '\"+databaseName+\"' model.\");\r\n    return;\r\n}\r\n\r\nif (runTMSL)\r\n{\r\n    Model.Database.TOMDatabase.Server.CancelSession(sID);\r\n    Info(\"Processing for the '\"+databaseName+\"' model has been cancelled (Session ID: \"+sID+\").\");\r\n}\r\nelse\r\n{\r\n    sID.Output();\r\n}",
      "Tooltip": "",
      "ValidContexts": "Model, Partition"
    },
    {
      "Id": 17,
      "Name": "Find string part of measure",
      "Enabled": "true",
      "Execute": "// Manually set the search term you want to look for in measures\nvar searchText = \"SUM(\"; // Change this value as needed\n\n// Create a list to collect measure names that contain the search text\nvar output = new List<string>();\n\n// Loop through each measure in the model\nforeach (var measure in Model.AllMeasures)\n{\n    // Check if the formula contains the search text (case-insensitive)\n    if (measure.Expression.ToLower().Contains(searchText.ToLower()))\n    {\n        // Add the measure name to the output list\n        output.Add(measure.Name);\n    }\n}\n\n// Output the result in the Advanced Scripting output pane as concatenated text\nif (output.Count > 0)\n{\n    // Join all measure names with \"; \" followed by a new line and output as a single string\n    Output(string.Join(\"; \" + Environment.NewLine, output));\n}\nelse\n{\n    Output($\"No measures contain '{searchText}'.\");\n}\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Id": 18,
      "Name": "Export all measures description into clipboard",
      "Enabled": "true",
      "Execute": "// Export all measures as DAX expressions and copy them to the clipboard\nvar sb = new System.Text.StringBuilder();\n\nforeach (var table in Model.Tables.Where(t => t.Measures.Count > 0))\n{\n    foreach (var measure in table.Measures)\n    {\n        sb.AppendLine($\"DEFINE MEASURE '{table.Name}'[{measure.Name}] = {measure.Expression}\");\n    }\n}\n\n// Copy result to clipboard\nSystem.Windows.Forms.Clipboard.SetText(sb.ToString());\n\n// Output for verification\nOutput(sb.ToString());\n",
      "Tooltip": "",
      "ValidContexts": "Model, Measure"
    },
    {
      "Id": 19,
      "Name": "Import all DEFINE MEASURES into model",
      "Enabled": "true",
      "Execute": "// Define the input containing measure definitions (replace this with actual measure definitions)\nvar input = \"DEFINE MEASURE 'Calculations'[Complex Care Ratio] = VAR _MinDate = MIN(FT_SALES_TRANSACTION[DATE_KEY]) VAR _MaxDate = MAX(FT_SALES_TRANSACTION[DATE_KEY]) VAR _CCSales = CALCULATE(DISTINCTCOUNT(FT_SALES_TRANSACTION[TRANSACTION_KEY]), REMOVEFILTERS(CAT_NONRX[CAT_NONRX]), REMOVEFILTERS(CAT_RX[CAT_RX]), DATESBETWEEN(D_DATE[DATE_KEY], _MinDate, _MaxDate), KEEPFILTERS(VALUES(D_DATE[DATE_KEY]))) VAR _BinSales = CALCULATE(DISTINCTCOUNT(FT_SALES_TRANSACTION[TRANSACTION_KEY]), DATESBETWEEN(D_DATE[DATE_KEY], _MinDate, _MaxDate), KEEPFILTERS(VALUES(D_DATE[DATE_KEY]))) RETURN DIVIDE(_BinSales, _CCSales);\\n\"\n+ \"DEFINE MEASURE 'Calculations'[Count of Cross Sales RX SKUs] = CALCULATE(SUM(FT_SALES_TRANSACTION[RX_ITEMS_COUNT]), FT_SALES_TRANSACTION[CATEGORY_COMPLEX_CARE_FLAG] = 1);\\n\"\n+ \"DEFINE MEASURE 'Calculations'[Complex Care Ratio2] = VAR _MinDate = MIN(FT_SALES_TRANSACTION[DATE_KEY]) VAR _MaxDate = MAX(FT_SALES_TRANSACTION[DATE_KEY]) VAR _CCSales = CALCULATE(DISTINCTCOUNT(FT_SALES_TRANSACTION[TRANSACTION_KEY]), REMOVEFILTERS(CAT_NONRX[CAT_NONRX]), REMOVEFILTERS(CAT_RX[CAT_RX]), DATESBETWEEN(D_DATE[DATE_KEY], _MinDate, _MaxDate), KEEPFILTERS(VALUES(D_DATE[DATE_KEY]))) VAR _BinSales = CALCULATE(DISTINCTCOUNT(FT_SALES_TRANSACTION[TRANSACTION_KEY]), DATESBETWEEN(D_DATE[DATE_KEY], _MinDate, _MaxDate), KEEPFILTERS(VALUES(D_DATE[DATE_KEY]))) RETURN DIVIDE(_BinSales, _CCSales);\";\n\n\n// Ensure the \"Calculations\" table exists\nvar tableName = \"Calculations\";\nvar table = Model.Tables.FirstOrDefault(t => t.Name == tableName);\nif (table == null)\n{\n    table = Model.AddTable(tableName);\n}\n\n// Process input lines\nvar lines = input.Split(new[] { '\\n' }, StringSplitOptions.RemoveEmptyEntries);\nforeach (var line in lines)\n{\n    if (line.StartsWith(\"DEFINE MEASURE\"))\n    {\n        var parts = line.Split(new[] { \"'\", \"[\", \"]\", \"=\" }, StringSplitOptions.RemoveEmptyEntries);\n        if (parts.Length >= 3)\n        {\n            var measureName = parts[2].Trim();\n            var expression = line.Substring(line.IndexOf(\"=\") + 1).Trim();\n\n            // Check if the measure already exists in \"Calculations\" table\n            var measure = table.Measures.FirstOrDefault(m => m.Name == measureName);\n            if (measure == null)\n            {\n                measure = table.AddMeasure(measureName, expression);\n            }\n            else\n            {\n                measure.Expression = expression;\n            }\n        }\n    }\n}\n\n// Output success message\nOutput(\"Measures imported into 'Calculations' table successfully. Save the model to apply changes.\");\n",
      "Tooltip": "",
      "ValidContexts": "Model, Measure"
    },
    {
      "Id": 20,
      "Name": "Export model aggregations (selected tables)",
      "Enabled": "true",
      "Execute": "if (Selected.Tables == null || Selected.Tables.Count() < 2)\n{\n    Output(\"Please select at least two tables: one base table and at least one aggregation table.\");\n    return;\n}\n\nvar _baseTable = Selected.Tables.OrderByDescending(t => t.Columns.Count).First();\nvar _aggTables = Selected.Tables.Where(t => t != _baseTable);\n\nvar _sb = new System.Text.StringBuilder();\n_sb.AppendLine(\"Base table;Aggregation table;ColumnName;Aggregation\");\n\nforeach (var _aggTable in _aggTables)\n{\n    foreach (var _col in _aggTable.Columns)\n    {\n        string _aggregation;\n        // Check if this aggregation column has been linked to a base column via AlternateOf.\n        if (_col.AlternateOf != null)\n        {\n            // The Summarization property on the aggregation column holds the aggregation type.\n            _aggregation = _col.AlternateOf.Summarization.ToString();\n        }\n        else\n        {\n            _aggregation = \"[No Aggregation]\";\n        }\n        _sb.AppendLine($\"{_baseTable.Name};{_aggTable.Name};{_col.Name};{_aggregation}\");\n    }\n}\n\n// Copy result to clipboard\nSystem.Windows.Forms.Clipboard.SetText(_sb.ToString());\n// Output for verification\nOutput(_sb.ToString());\n",
      "Tooltip": "",
      "ValidContexts": "Model, Table, Column"
    },
    {
      "Id": 21,
      "Name": "Full model definition export",
      "Enabled": "true",
      "Execute": "using System.Text;\n\n// No 'using Microsoft.AnalysisServices.Tabular;' – everything is TOMWrapper\n\nvar sb = new StringBuilder();\n\nsb.AppendLine($\"Model: {Model.Name}\");\nsb.AppendLine(new string('-', 50));\n\n// TABLES, COLUMNS, MEASURES, PQ PARTITIONS\nforeach (var table in Model.Tables)\n{\n    sb.AppendLine($\"Table: {table.Name}\");\n    if (!string.IsNullOrWhiteSpace(table.Description))\n        sb.AppendLine($\"  Description: {table.Description}\");\n\n    sb.AppendLine(\"  Columns:\");\n    foreach (var column in table.Columns)\n        sb.AppendLine($\"    - {column.Name} ({column.DataType}){(column.IsHidden ? \" [Hidden]\" : \"\")}\");\n\n    // Power Query Partition Definitions (M Expressions)\n    if (table.Partitions.Count > 0)\n    {\n        sb.AppendLine(\"  Partitions:\");\n        foreach (var partition in table.Partitions)\n        {\n            var mPartition = partition as TabularEditor.TOMWrapper.MPartition;\n            if (mPartition != null)\n            {\n                sb.AppendLine($\"    - {mPartition.Name}:\");\n                sb.AppendLine(\"        Source:\");\n                if (!string.IsNullOrWhiteSpace(mPartition.Expression))\n                    sb.AppendLine(\"        \" + mPartition.Expression.Replace(\"\\n\", \"\\n        \"));\n                else\n                    sb.AppendLine(\"        [No Expression]\");\n            }\n        }\n    }\n\n    // Measures\n    if (table.Measures.Count > 0)\n    {\n        sb.AppendLine(\"  Measures:\");\n        foreach (var measure in table.Measures)\n        {\n            sb.AppendLine($\"    - {measure.Name}:\");\n            sb.AppendLine($\"        {measure.Expression}\");\n        }\n    }\n\n    sb.AppendLine();\n}\n\n// RELATIONSHIPS\nsb.AppendLine(\"Relationships:\");\nforeach (var rel in Model.Relationships)\n{\n    var scRel = rel as TabularEditor.TOMWrapper.SingleColumnRelationship;\n    if (scRel != null)\n    {\n        sb.AppendLine(\n            $\"  {scRel.FromTable.Name}.{scRel.FromColumn.Name} -> {scRel.ToTable.Name}.{scRel.ToColumn.Name} \" +\n            $\"(Active: {scRel.IsActive}, CrossFilteringBehavior: {scRel.CrossFilteringBehavior})\"\n        );\n    }\n    else\n    {\n        sb.AppendLine(\n            $\"  [Relationship: {rel.Name}] (Type: {rel.GetType().Name}, Active: {rel.IsActive})\"\n        );\n    }\n}\n\n// ROLE-LEVEL SECURITY\nsb.AppendLine();\nsb.AppendLine(\"Role-Level Security (RLS):\");\nforeach (var role in Model.Roles)\n{\n    sb.AppendLine($\"  Role: {role.Name}\");\n    foreach (var perm in role.TablePermissions)\n    {\n        if (!string.IsNullOrWhiteSpace(perm.FilterExpression))\n        {\n            sb.AppendLine($\"    - Table: {perm.Name}\");\n            sb.AppendLine($\"        Filter: {perm.FilterExpression}\");\n        }\n    }\n}\n\nOutput(sb.ToString());\n",
      "Tooltip": "Exprot full model definition into output window to be copypasted",
      "ValidContexts": "SingularObjects"
    },
        {
      "Id": 22,
      "Name": "Referential integrity check",
      "Enabled": "true",
      "Execute": "//Select the desired table to store all data quality measures\n\n\nstring overallCounterExpression = \"\";\nstring overallCounterName = \"Total Unmapped Items\";\n\nstring overallDetailExpression = \"\\\"\\\"\";\nstring overallDetailName = \"Data Problems\";\n\nTable tableToStoreMeasures = Selected.Tables.First();\n\nforeach (var r in Model.Relationships)\n{\n\n\n    bool isOneToMany =\n        r.FromCardinality == RelationshipEndCardinality.One\n        & r.ToCardinality == RelationshipEndCardinality.Many;\n\n    bool isManyToOne =\n        r.FromCardinality == RelationshipEndCardinality.Many\n        & r.ToCardinality == RelationshipEndCardinality.One;\n\n    Column manyColumn = null as Column;\n    Column oneColumn = null as Column;\n    bool isOneToManyOrManyToOne = true;\n    if (isOneToMany)\n    {\n        manyColumn = r.ToColumn;\n        oneColumn = r.FromColumn;\n\n    }\n    else if (isManyToOne)\n    {\n        manyColumn = r.FromColumn;\n        oneColumn = r.ToColumn;\n    }\n    else\n    {\n        isOneToManyOrManyToOne = false;\n    }\n\n    if (isOneToManyOrManyToOne)\n    {\n\n        string orphanCountExpression =\n            \"CALCULATE(\"\n                + \"SUMX(VALUES(\" + manyColumn.DaxObjectFullName + \"),1),\"\n                + oneColumn.DaxObjectFullName + \" = BLANK()\"\n            + \")\";\n        string orphanMeasureName =\n            manyColumn.Name + \" not mapped in \" + manyColumn.Table.Name;\n\n        Measure newCounter = tableToStoreMeasures.AddMeasure(name: orphanMeasureName, expression: orphanCountExpression,displayFolder:\"_Data quality Measures\");\n        newCounter.FormatDax(); \n\n        string orphanTableTitleMeasureExpression = newCounter.DaxObjectFullName + \" & \\\" \" + newCounter.Name + \"\\\"\";\n        string orphanTableTitleMeasureName = newCounter.Name + \" Title\";\n\n        Measure newTitle = tableToStoreMeasures.AddMeasure(name: orphanTableTitleMeasureName, expression: orphanTableTitleMeasureExpression, displayFolder: \"_Data quality Titles\");\n        newTitle.FormatDax();\n\n        overallCounterExpression = overallCounterExpression + \"+\" + newCounter.DaxObjectFullName;\n        overallDetailExpression = overallDetailExpression\n                + \" & IF(\" + newCounter.DaxObjectFullName + \"> 0,\"\n                            + newTitle.DaxObjectFullName + \" & UNICHAR(10))\";\n\n    };\n\n};\n\nMeasure counter = tableToStoreMeasures.AddMeasure(name: overallCounterName, expression: overallCounterExpression);\ncounter.FormatDax();\n\n\nMeasure descr = tableToStoreMeasures.AddMeasure(name: overallDetailName, expression: overallDetailExpression);\ndescr.FormatDax();",
      "Tooltip": "",
      "ValidContexts": "Model, Table, Relationship"
    },
    {
      "Id": 23,
      "Name": "TMDL Slimmer",
      "Enabled": "true",
      "Execute": "//\n// Title: TMDL Slimmer - Strip metadata bloat for LLM context\n//\n// Author: Alexis Olson\n// Version: 1.1\n//\n// Description:\n//   Reads all *.tmdl files from a SemanticModel/definition folder,\n//   removes UI/engine metadata while preserving model semantics,\n//   and outputs a single .slimdl file for LLM consumption.\n//\n// Usage:\n//   - Run in Tabular Editor 2 or 3 (Advanced Scripting)\n//   - Select your SemanticModel folder when prompted\n//   - Choose where to save the output .slimdl file\n\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Windows.Forms;\n\n// ==================== CONFIGURATION ====================\nbool REMOVE_Annotations  = true; // annotation, changedProperty, extendedProperty/extendedProperties\nbool REMOVE_Lineage      = true; // lineageTag, sourceLineageTag\nbool REMOVE_LanguageData = true; // cultures folder (includes linguisticMetadata)\nbool REMOVE_ColumnMeta   = true; // summarizeBy, sourceColumn, dataCategory (+ select column booleans)\nbool REMOVE_InferredMeta = true; // isNameInferred, isDataTypeInferred, sourceProviderType\nbool REMOVE_DisplayProps = true; // isHidden, displayFolder, formatString, isDefaultLabel/Image\n\n// ==================== MAIN EXECUTION ====================\ntry\n{\n    // Select SemanticModel folder\n    string modelFolder = null;\n    using (var dialog = new FolderBrowserDialog())\n    {\n        dialog.Description = \"Select the SemanticModel folder (contains 'definition' subfolder)\";\n        dialog.ShowNewFolderButton = false;\n        if (dialog.ShowDialog() != DialogResult.OK) return;\n        modelFolder = dialog.SelectedPath;\n    }\n\n    // Locate definition root - handle both cases: user selected SemanticModel or definition directly\n    string definitionPath = Path.Combine(modelFolder, \"definition\");\n    if (!Directory.Exists(definitionPath))\n    {\n        definitionPath = modelFolder; // Fallback: user already selected the definition folder\n        if (Directory.GetFiles(definitionPath, \"*.tmdl\", SearchOption.AllDirectories).Length == 0)\n        {\n            Info(\"No TMDL files found in the selected folder.\");\n            return;\n        }\n    }\n\n    // Build removal patterns based on configuration flags\n    var patterns = new Dictionary<string, Regex>();\n\n    // Common regex components for matching property assignments\n    string ASSIGN = @\"\\s*(?:=|:)\"; // matches optional whitespace then = or :\n    string BOOL   = @\"(?:\\s*(?:=|:)\\s*(?:true|false))?\\s*;?\\s*$\"; // matches optional boolean and semicolon\n\n    // Helper to add patterns when corresponding removal flag is enabled\n    Action<bool,string,string> Add = (flag, name, pattern) =>\n    {\n        if (flag) patterns[name] = new Regex(pattern);\n    };\n\n    // Annotations group\n    Add(REMOVE_Annotations,  \"annotation\",         @\"^\\s*annotation\\b\");\n    Add(REMOVE_Annotations,  \"changedProperty\",    @\"^\\s*changedProperty\\b\");\n    Add(REMOVE_Annotations,  \"extendedProperty\",   @\"^\\s*extendedPropert(?:y|ies)\\b\");\n\n    // Lineage tracking group\n    Add(REMOVE_Lineage,      \"lineageTag\",         @\"^\\s*lineageTag\" + ASSIGN);\n    Add(REMOVE_Lineage,      \"sourceLineageTag\",   @\"^\\s*sourceLineageTag\" + ASSIGN);\n\n    // Column metadata group\n    Add(REMOVE_ColumnMeta,   \"dataCategory\",       @\"^\\s*dataCategory\" + ASSIGN);\n    Add(REMOVE_ColumnMeta,   \"summarizeBy\",        @\"^\\s*summarizeBy\" + ASSIGN);\n    Add(REMOVE_ColumnMeta,   \"sourceColumn\",       @\"^\\s*sourceColumn\" + ASSIGN);\n    Add(REMOVE_ColumnMeta,   \"isAvailableInMdx\",   @\"^\\s*isAvailableInMdx\" + BOOL);\n    Add(REMOVE_ColumnMeta,   \"isNullable\",         @\"^\\s*isNullable\" + BOOL);\n\n    // Inferred metadata group\n    Add(REMOVE_InferredMeta, \"isNameInferred\",     @\"^\\s*isNameInferred\" + BOOL);\n    Add(REMOVE_InferredMeta, \"isDataTypeInferred\", @\"^\\s*isDataTypeInferred\" + BOOL);\n    Add(REMOVE_InferredMeta, \"sourceProviderType\", @\"^\\s*sourceProviderType\" + ASSIGN);\n\n    // Display/UI properties group\n    Add(REMOVE_DisplayProps, \"isHidden\",           @\"^\\s*isHidden\" + BOOL);\n    Add(REMOVE_DisplayProps, \"displayFolder\",      @\"^\\s*displayFolder\" + ASSIGN);\n    Add(REMOVE_DisplayProps, \"formatString\",       @\"^\\s*formatString\" + ASSIGN);\n    Add(REMOVE_DisplayProps, \"isDefaultLabel\",     @\"^\\s*isDefaultLabel\" + BOOL);\n    Add(REMOVE_DisplayProps, \"isDefaultImage\",     @\"^\\s*isDefaultImage\" + BOOL);\n\n    // Identify patterns that start multi-line blocks (need brace tracking)\n    var blockStarters = new HashSet<string>();\n    if (REMOVE_Annotations)  {\n        blockStarters.Add(\"extendedProperty\");\n    }\n\n    // Track removal statistics for summary report\n    var removalStats = new Dictionary<string, int>();\n\n    // Small helper to increment removal counters deterministically\n    Action<string> Bump = key =>\n    {\n        int v;\n        if (!removalStats.TryGetValue(key, out v)) v = 0; removalStats[key] = v + 1;\n    };\n\n    // Collect all TMDL files recursively\n    string[] tmdlFiles = Directory.GetFiles(definitionPath, \"*.tmdl\", SearchOption.AllDirectories);\n    Array.Sort(tmdlFiles);\n    if (tmdlFiles.Length == 0)\n    {\n        Info(\"No TMDL files found in the selected folder.\");\n        return;\n    }\n\n    // Initialize output with header\n    var output = new StringBuilder();\n    output.AppendLine(\"// Combined TMDL (Slim)\");\n    output.AppendLine(\"// Source: \" + Path.GetFileName(modelFolder));\n    output.AppendLine(\"// Generated: \" + DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss\"));\n\n    long originalTotalSize = 0;\n    long culturesBytesRemoved = 0; // bytes saved by excluding cultures/ folder\n    int culturesFilesSkipped = 0;  // number of cultures/ tmdl files skipped\n    int filesWithContent = 0;\n\n    // Calculate base path for relative file names (normalize with trailing separator)\n    string definitionBasePath = definitionPath.TrimEnd('\\\\', '/') + Path.DirectorySeparatorChar;\n\n    // Process each TMDL file\n    foreach (string filePath in tmdlFiles)\n    {\n        // Calculate relative path from definition root\n        string relativePath = filePath.StartsWith(definitionBasePath)\n            ? filePath.Substring(definitionBasePath.Length)\n            : Path.GetFileName(filePath);\n        relativePath = relativePath.Replace('\\\\', '/');\n\n        // Include every file's size in input total, even if we skip its content later\n        long fileSize = new FileInfo(filePath).Length;\n        originalTotalSize += fileSize;\n\n        // Skip entire cultures/ subtree when language data removal is enabled\n        if (REMOVE_LanguageData && relativePath.StartsWith(\"cultures/\"))\n        {\n            culturesBytesRemoved += fileSize; // track savings from cultures folder\n            culturesFilesSkipped++;\n            continue;\n        }\n\n        // Read file content\n        string content = File.ReadAllText(filePath, Encoding.UTF8);\n\n        // Process content line by line\n        string[] contentLines = content.Split(new[] { \"\\r\\n\", \"\\n\", \"\\r\" }, StringSplitOptions.None);\n\n        // State tracking for multi-line block removal\n        bool inSkippedBlock = false;\n        int blockBraceDepth = 0;\n        bool fileHasOutput = false;\n\n        foreach (string line in contentLines)\n        {\n            // Handle multi-line block skipping (tracks nested braces)\n            if (inSkippedBlock)\n            {\n                blockBraceDepth += line.Split('{').Length - 1;\n                blockBraceDepth -= line.Split('}').Length - 1;\n                if (blockBraceDepth <= 0) \n                { \n                    inSkippedBlock = false; \n                    blockBraceDepth = 0;\n                    continue; // Don't output closing brace line that ended the block\n                }\n                continue; // Continue skipping lines inside the block\n            }\n\n            // Check if current line matches any removal pattern\n            bool shouldRemoveLine = false;\n            foreach (var patternEntry in patterns)\n            {\n                if (patternEntry.Value.IsMatch(line))\n                {\n                    // Check if this starts a multi-line block that needs brace tracking\n                    if (blockStarters.Contains(patternEntry.Key))\n                    {\n                        Bump(patternEntry.Key);\n\n                        // Initialize brace tracking for this block\n                        blockBraceDepth = line.Split('{').Length - line.Split('}').Length;\n                        inSkippedBlock = true;\n                        shouldRemoveLine = true;\n                        break;\n                    }\n                    else\n                    {\n                        // Single-line removal\n                        Bump(patternEntry.Key);\n                        shouldRemoveLine = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!shouldRemoveLine)\n            {\n                // Skip pure whitespace lines to reduce output bloat\n                if (string.IsNullOrWhiteSpace(line))\n                    continue;\n\n                // Keep the line (trim trailing whitespace for consistency)\n                output.AppendLine(line.TrimEnd());\n                fileHasOutput = true;\n            }\n        }\n\n        if (fileHasOutput)\n        {\n            filesWithContent++;\n            output.AppendLine(); // Ensure separation between files\n        }\n    }\n\n    // Squeeze excessive blank lines to maximum of one blank line\n    string finalOutput = Regex.Replace(output.ToString(), @\"(\\r?\\n){3,}\", Environment.NewLine + Environment.NewLine);\n    finalOutput = finalOutput.TrimEnd() + Environment.NewLine; // Ensure file ends with newline\n\n    // Get output path via save dialog\n    var parentDir = Directory.GetParent(modelFolder);\n    string suggestedPath = Path.Combine(parentDir != null ? parentDir.FullName : modelFolder,\n                                        Path.GetFileName(modelFolder) + \".slimdl\");\n\n    string outputPath;\n    using (var saveDialog = new SaveFileDialog())\n    {\n        saveDialog.Title = \"Save slimmed TMDL\";\n        saveDialog.Filter = \"Slimmed TMDL (*.slimdl)|*.slimdl|TMDL files (*.tmdl)|*.tmdl|All files (*.*)|*.*\";\n        saveDialog.DefaultExt = \"slimdl\";\n        saveDialog.AddExtension = true;\n        saveDialog.FileName = Path.GetFileName(suggestedPath);\n        saveDialog.InitialDirectory = Path.GetDirectoryName(suggestedPath);\n        saveDialog.OverwritePrompt = true;\n        saveDialog.CheckPathExists = true;\n\n        if (saveDialog.ShowDialog() != DialogResult.OK) return;\n        outputPath = saveDialog.FileName;\n    }\n\n    // Write the combined, slimmed TMDL\n    File.WriteAllText(outputPath, finalOutput, new UTF8Encoding(false));\n\n    // Calculate size reduction metrics\n    long outputSize = new FileInfo(outputPath).Length;\n    double reductionPercent = (originalTotalSize > 0) \n        ? (1.0 - (double)outputSize / (double)originalTotalSize) * 100.0 \n        : 0.0;\n\n    // Generate summary report\n    var summary = new StringBuilder();\n    summary.AppendLine(\"TMDL Slimmer Results\");\n    summary.AppendLine(\"====================\");\n    summary.AppendLine(string.Format(\"Files processed: {0} of {1}\", filesWithContent, tmdlFiles.Length));\n    if (culturesFilesSkipped > 0)\n        summary.AppendLine(string.Format(\"Culture files not processed: {0}\", culturesFilesSkipped));\n    summary.AppendLine(string.Format(\"Input size:  {0:N1} KB\", originalTotalSize / 1024.0));\n    summary.AppendLine(string.Format(\"Output size: {0:N1} KB\", outputSize / 1024.0));\n    summary.AppendLine(string.Format(\"Size reduction: {0:F1}%\", reductionPercent));\n\n    if (removalStats.Count > 0)\n    {\n        int totalRemovals = 0;\n        foreach (int count in removalStats.Values) totalRemovals += count;\n        summary.AppendLine();\n        if (culturesBytesRemoved > 0)\n            summary.AppendLine(string.Format(\"Removed cultures folder: {0:N1} KB\", culturesBytesRemoved / 1024.0));\n        summary.AppendLine();\n        summary.AppendLine(string.Format(\"Removed {0:N0} items:\", totalRemovals));\n\n        var sortedKeys = new List<string>(removalStats.Keys);\n        sortedKeys.Sort();\n        foreach (string key in sortedKeys)\n            summary.AppendLine(string.Format(\"  - {0}: {1:N0}\", key, removalStats[key]));\n    }\n\n    Info(summary.ToString());\n}\ncatch (Exception ex)\n{\n    Error(\"Processing failed: \" + ex.Message);\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    }
  ]
}